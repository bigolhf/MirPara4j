
package no.uio.medisin.bag.jmirpara;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Class to parse the sequence and structure of a pri-miRNA, pre-miRNA and miRNA
 * The secondary structure is assumed to be generated by RNAFold, insofar as the
 * structure is defined using Vienna dot bracket notation @see <a href="http://rna.tbi.univie.ac.at/help.html#A6">doc bracket notation</a>.
 * If a hairpin structure is present in the predicted structure, it must have 
 * the form:
 *    (((.(((....)))..))
 * i.e, a series of '.' bounded on the left side by a succession of '(' and '.' 
 * and on the right side by a similar number of ')' and '.'
 * This structure is encapsulated by a regular expression which is used to 
 * search the predicted structure for the presence of a hairpin. 
 * 
 * The detailed parsing of the predicted structure is carried out in {@link #parsePrimiRNA(String)}
 * 
 * @author weibo and Simon Rayner
 * 
 */
public class CharacterizedPriMiRNA {
    
    static Logger logger = LogManager.getRootLogger();    

    private PriMiRNA priRNA;
    private PreMiRNA preRNA;
    private MiRNA miRNA;

    private String priStructLine1;
    private String priStructLine2;
    private String priStructLine3;
    private String priStructLine4;
            String se= "AAGCUGGCAUUCUAUAUAAGAGAGAAACUACACGCAGCGCCUCAUUUUGUGGGUCA"
              + "CCAUAUUCUUGGGAACAAGAGCUACAGCAUGGGGCAAAUCUUUCUGUUCCCAAUCCUCUGGGA"
              + "UUCUUUCCCGAUCACCAGUUGGACCCUGCGUUUGGAGCCAACUCAAACAAUCCAGAUUGGGAC"
              + "UUCAACCCCAACAAGGAUCACUGGCCAGAGGCAAAUCAGGUAGGAGCGGGAGCAUUCGGGCCA"
              + "GGGUUCACCCC";
            String st = "";

    /*
       The following RegEx is basically comprised of five parts:
            
            (\\.*)                 : 0 or more '.'         : unmatched bases at 5'' end
            (\\([\\.\\(]*\\()      : 0 or more '.' and '(' : 5' paired bases on stem 
            (\\.+)                 : 0 or more '.' and ')' : terminal loop
            (\\)[\\.\\)]*\\))      : 0 or more '.' and ')' : 3' paired bases on stem            
            (\\.*)                 : 0 or more             : unmatched bases at 3' end
            
     */
    private static String regSL="(\\.*)(\\([\\.\\(]*\\()(\\.+)(\\)[\\.\\)]*\\))(\\.*)";
                                // (1)........(2).........(3).......(4)..........(5)
    private Pattern stemLoopPattern = Pattern.compile(regSL);
    private Matcher StemLoopMatch;

    public CharacterizedPriMiRNA(PriMiRNA pri){
        
        priRNA = pri;
        
    }

    /**
     * parse features of pri-miRNA
     */
    public void parsePrimiRNA(){

        parsePriStr(priRNA);

        priStructLine1 = priRNA.getPriLine1();
        priStructLine2 = priRNA.getPriLine2();
        priStructLine3 = priRNA.getPriLine3();
        priStructLine4 = priRNA.getPriLine4();
        
        //nucleotide content
        priRNA.setGC_content(GCcontent(priRNA.getSeq()));
        priRNA.setA_content(NTcontent(priRNA.getSeq(), 'A') + NTcontent(priRNA.getSeq(), 'a'));
        priRNA.setU_content(NTcontent(priRNA.getSeq(), 'U') + NTcontent(priRNA.getSeq(), 'u'));
        priRNA.setG_content(NTcontent(priRNA.getSeq(), 'G') + NTcontent(priRNA.getSeq(), 'g'));
        priRNA.setC_content(NTcontent(priRNA.getSeq(), 'C') + NTcontent(priRNA.getSeq(), 'c'));
        priRNA.setNumberOfGUPairs(CountRNAFoldGUpairs(priStructLine2, priStructLine3));
        priRNA.setNumberOfPairedBases(pairCount(priStructLine2));

        //priRNA unpaired base do not include basal part and terminalloop
        priRNA.setNumberOfUnpairedBasesInStem(this.countNumberOfUnpairedBasesInStem());
        priRNA.setNumberOfUnpairedBasesInStem(unpairedCount(priStructLine1,priStructLine4) - priRNA.getBasalBaseNum() -
                (priRNA.getTerminalLoopSeq().length() - priRNA.getMidBase().length()));
        priRNA.setunpairedBaseRate(calcUnpairedRate(
                priRNA.getNumberOfUnpairedBasesInStem(), priRNA.getNumberOfPairs()));

        //priRNA internal loops DO NOT include basal part or the Terminal Loop
        priRNA.setInternalLoop_num(internalLoopCount(priStructLine2));
        priRNA.setInternalLoopSize(findLargestInternalLoopOnStem(priStructLine1, priStructLine4));

        priRNA.buildFeatureSet();
    }

    
    
    /**
     * generate an miRNA and pre-miRNA from the pri-miRNA based on the given 
     * miRNA start position and length 
     * 

     * @param miRStartPos--miRNA start, count from 0
     * @param miRLength--miRNA length
     * 
     */
    public void defineAndCharacterizePreMiPair(int miRStartPos, int miRLength){

        preRNA = new PreMiRNA();
        miRNA = new MiRNA();

        int strand=findStrand(priRNA, miRStartPos, miRLength);
        int upperStart=0, upperEnd=0;
        int[] strIndex=priRNA.getStrIndex();
        
        String midBase=priRNA.getMidBase();
        int basalEnd=priRNA.getBasalSegEnd();//count from 1

        priStructLine1=priRNA.getPriLine1();
        priStructLine2=priRNA.getPriLine2();
        priStructLine3=priRNA.getPriLine3();
        priStructLine4=priRNA.getPriLine4();
        String preMiRNAStructLine1;
        String preMiRNAStructLine2;
        String preMiRNAStructLine3;
        String preMiRNAStructLine4;
        String miRStructLine1;
        String miRStructLine2;
        String miRStructLine3;
        String miRStructLine4;
        String lowerStemStructLine1;
        String lowerStemStructLine2;
        String lowerStemStructLine3;
        String lowerStemStructLine4;
        String topStemStructLine1;
        String topStemStructLine2;
        String topStemStructLine3;
        String topStemStructLine4;
        
        String dangle;

        if (strand == 5) {
            upperStart = strIndex[miRStartPos];//count from 0
            upperEnd = strIndex[miRStartPos + miRLength - 1];//count from 0

        } else if (strand == 3) {
            upperStart = strIndex[miRStartPos + miRLength - 1];
            upperEnd = strIndex[miRStartPos];
        }
        else return;//do something...

        // all positions below count from 1

        priRNA.setPriPlot(generatePrettyPlotShowingMiRNA(priRNA,upperStart,upperEnd, strand));

        // set candidate pre-miRNA parameters
        preMiRNAStructLine1 = priStructLine1.substring(upperStart);
        preMiRNAStructLine2 = priStructLine2.substring(upperStart);
        preMiRNAStructLine3 = priStructLine3.substring(upperStart);
        preMiRNAStructLine4 = priStructLine4.substring(upperStart);
        preRNA.setUpperStart(upperStart + 1);
        preRNA.setUpperEnd(upperEnd + 1);
        preRNA.setSeq(PrettyPlot2Seq(preMiRNAStructLine1, preMiRNAStructLine2) + midBase + reverse(PrettyPlot2Seq(preMiRNAStructLine4, preMiRNAStructLine3)));
        preRNA.setLength(preRNA.getSeq().length());
        preRNA.setAbsStartInQuerySeq(PrettyPlot2Seq(priStructLine1.substring(0, upperStart), priStructLine2.substring(0, upperStart)).length());
        preRNA.setEnergy(calculatePreMFE(priRNA.getStructureStr(), preRNA.getSeq(), preRNA.getStart()));
        
        preRNA.setGC_content(GCcontent(preRNA.getSeq()));
        preRNA.setA_content(NTcontent(preRNA.getSeq(),'A')+NTcontent(preRNA.getSeq(),'a'));
        preRNA.setU_content(NTcontent(preRNA.getSeq(),'U')+NTcontent(preRNA.getSeq(),'u'));
        preRNA.setG_content(NTcontent(preRNA.getSeq(),'G')+NTcontent(preRNA.getSeq(),'g'));
        preRNA.setC_content(NTcontent(preRNA.getSeq(),'C')+NTcontent(preRNA.getSeq(),'c'));

        preRNA.setNumberOfGUPairs(CountRNAFoldGUpairs(preMiRNAStructLine2, preMiRNAStructLine3));

        preRNA.setNumberOfPairedBases(pairCount(preMiRNAStructLine2));
        
        //preRNA unpaired bases, do not include terminal loop bases
        preRNA.setNumberOfUnpairedBases(unpairedCount(preMiRNAStructLine1, preMiRNAStructLine4) - (priRNA.getTerminalLoopSize() - midBase.length()));
        preRNA.setUnpairedBaseRate(calcUnpairedRate(preRNA.getUnpairedBase_num(), preRNA.getNumberOfPairs()));
        
        //preRNA internal loop, do not include terminal loop
        preRNA.setNumberOfInternalLoops(internalLoopCount(preMiRNAStructLine2));
        preRNA.setBiggestInternalLoop(findLargestInternalLoopOnStem(preMiRNAStructLine1, preMiRNAStructLine4));

        
        
        //set lowerStem parameters
        if (basalEnd < upperStart) {
            lowerStemStructLine1 = priStructLine1.substring(basalEnd, upperStart);
            lowerStemStructLine2 = priStructLine2.substring(basalEnd, upperStart);
            lowerStemStructLine3 = priStructLine3.substring(basalEnd, upperStart);
            lowerStemStructLine4 = priStructLine4.substring(basalEnd, upperStart);
            
            preRNA.setLowerStemLength(upperStart-basalEnd);
            
            preRNA.setNumOfUnpairedBasesInLowerStem(unpairedCount(lowerStemStructLine1, lowerStemStructLine4));
            preRNA.setFractOfUnpairedBasesInLowerStem(calcUnpairedRate(preRNA.getLowerStemUnpairedBase_num(), pairCount(lowerStemStructLine2)));

            preRNA.getNumOfInternalLoopsInLowerStem(internalLoopCount(lowerStemStructLine2));
            preRNA.SetLargestInternalLoopInLowerStem(findLargestInternalLoopOnStem(lowerStemStructLine1, lowerStemStructLine4));
        }

        preRNA.setUpperStemSize(upperEnd - upperStart + 1);

        
        
        //set topStem parameters
        int stemEnd = strIndex[priRNA.getTerminalLoopStart()-1];//count from 1
        if (upperEnd + 1 < stemEnd) {
            topStemStructLine1 = priStructLine1.substring(upperEnd + 1, stemEnd);
            topStemStructLine2 = priStructLine2.substring(upperEnd + 1, stemEnd);
            topStemStructLine3 = priStructLine3.substring(upperEnd + 1, stemEnd);
            topStemStructLine4 = priStructLine4.substring(upperEnd + 1, stemEnd);

            preRNA.setTopStemSize(stemEnd - upperEnd - 1);

            preRNA.setNumOfUnpairedBasesInTopStem(unpairedCount(topStemStructLine1, topStemStructLine4));
            preRNA.setFractOfUnpairedBasesInTopStem(calcUnpairedRate(preRNA.getTopStemUnpairedBase_num(), pairCount(topStemStructLine2)));

            preRNA.setNumOfInternalLoopsInTopStem(internalLoopCount(topStemStructLine2));
            preRNA.setTopStemInternalLoopSize(findLargestInternalLoopOnStem(topStemStructLine1, topStemStructLine4));
        }
        preRNA.buildFeatureSet();


        //set candidate miRNA parameters
        miRStructLine1 = priStructLine1.substring(upperStart, upperEnd + 1);
        miRStructLine2 = priStructLine2.substring(upperStart, upperEnd + 1);
        miRStructLine3 = priStructLine3.substring(upperStart, upperEnd + 1);
        miRStructLine4 = priStructLine4.substring(upperStart, upperEnd + 1);
        
        miRNA.setSeq(priRNA.getSeq().substring(miRStartPos, miRStartPos + miRLength));
        miRNA.setLength(miRNA.getSeq().length());
        miRNA.setGC_content(GCcontent(miRNA.getSeq()));

        miRNA.setA_content(NTcontent(miRNA.getSeq(),'A')+NTcontent(miRNA.getSeq(),'a'));
        miRNA.setU_content(NTcontent(miRNA.getSeq(),'U')+NTcontent(miRNA.getSeq(),'u'));
        miRNA.setG_content(NTcontent(miRNA.getSeq(),'G')+NTcontent(miRNA.getSeq(),'g'));
        miRNA.setC_content(NTcontent(miRNA.getSeq(),'C')+NTcontent(miRNA.getSeq(),'c'));

        miRNA.setNumberOfGUPairs(CountRNAFoldGUpairs(miRStructLine2, miRStructLine3));

        miRNA.setNumberOfPairedBases(pairCount(miRStructLine2));

        miRNA.setNumberOfUnpairedBases(unpairedCount(miRStructLine1, miRStructLine4));
        miRNA.setFractOfUnpairedBases(calcUnpairedRate(miRNA.getUnpairedBase_num(), miRNA.getNumberOfPairs()));

        miRNA.setNumOfInternalLoops(internalLoopCount(miRStructLine2));
        miRNA.setLargestInternalLoop(findLargestInternalLoopOnStem(miRStructLine1, miRStructLine4));

        miRNA.setFirstBase(priRNA.getSeq().charAt(miRStartPos));
        miRNA.setMiRNAStartPos(miRStartPos + 1);
        miRNA.setMiRNAEndPos(miRStartPos + miRLength);
        miRNA.setAbsStartInQuerySeq(miRStartPos + priRNA.getStart()); // <- what is this start pos?? position within the full sequence I think
        miRNA.setAbsEndInQuerySeq(miRNA.getStart() + miRLength - 1);
        miRNA.setLength(miRLength);
        miRNA.setStrand(strand);
        
        //miRNA dangle (SR: I think this can only be up to 2 nt)
        if (strand == 5) {
            dangle = findDangleSeq(priStructLine3.length()-upperStart-1, reverse(priStructLine4), reverse(priStructLine3));
        } else {
            dangle = findDangleSeq(upperEnd,priStructLine1, priStructLine2);
        }

        miRNA.setDangleBaseOne(dangle.charAt(0));
        miRNA.setDangleBaseTwo(dangle.charAt(1));

        miRNA.setStability(stability(miRStructLine2, miRStructLine3, strand));

        miRNA.setName(priRNA.getName());
        miRNA.setID(miRNA.getName() + "_MIR_" + miRNA.getStart()
                + "-" + miRNA.getLength());

        miRNA.buildFeatureSet();

        //store product in priRNA
//        preRNA.addProduct(miRNA);
//        priRNA.addProduct(preRNA);
    }


    
    
    
    /**
     * parse the hairpin structure of a pri-miRNA.
     * positions start from 1
     * 
     * @param priRNA
     * @return boolean
     * 
     */
    public boolean parsePriStr(PriMiRNA priRNA){
        
        StemLoopMatch = stemLoopPattern.matcher(priRNA.getStructureStr());

        if (StemLoopMatch.matches()) {
            priRNA.setBasalSegSize(Math.max(StemLoopMatch.group(1).length(), StemLoopMatch.group(5).length())); // length of overhang on 5' or 3' end
            priRNA.setBasalSegEnd(priRNA.getBasalSegSize());                                                    //count from 1
            priRNA.setBasalBaseNum(StemLoopMatch.group(1).length() + StemLoopMatch.group(5).length());          // length after trimming back the overhang from the 5' or 5' end

            priRNA.setTerminalLoopSeq(priRNA.getSeq().substring(StemLoopMatch.start(3), StemLoopMatch.end(3)));
            priRNA.setTerminalLoopSize(priRNA.getTerminalLoopSeq().length());
            priRNA.setTerminalLoopStart(StemLoopMatch.start(3)+1);//count from 1
            priRNA.setTerminalLoopEnd(StemLoopMatch.end(3));//count from 1

            // SR: I think these are calculated in order to determine the base in the middle of the terminal loop 
            int end5 = StemLoopMatch.end(2) + (StemLoopMatch.end(3) - StemLoopMatch.start(3)) / 2; //5' end, count from 1
            int start3 = StemLoopMatch.start(4) - (StemLoopMatch.end(3) - StemLoopMatch.start(3)) / 2; //3' start, count from 0
            
            priRNA.setMiddleBase("");
            if (end5 < start3)
                priRNA.setMiddleBase(priRNA.getSeq().charAt(end5)+"");//top base on the terminal loop
                        //include terminal loop
            priRNA.setSeq5(priRNA.getSeq().substring(0, end5));
            priRNA.setStr5(priRNA.getStructureStr().substring(0, end5));
            priRNA.setSeq3(priRNA.getSeq().substring(start3));
            priRNA.setStr3(priRNA.getStructureStr().substring(start3));

            priRNA.setStrIndex(VienBK2PrettyPlot(priRNA));
            
            return true;
        }
        return false;
    }

    
    
    /**
     * transform bracket-dot notation string structure to Pretty text plot and
     * store index of the bases on the plot
     * 
     * @param priRNA
     * @return
     * 
     */
    public int[] VienBK2PrettyPlot(PriMiRNA priRNA) {
        
        
        StringBuilder pril1=new StringBuilder();
        StringBuilder pril2=new StringBuilder();
        StringBuilder pril3=new StringBuilder();
        StringBuilder pril4=new StringBuilder();
        String seq5=priRNA.getSeq5();
        String str5=priRNA.getStr5();
        String seq3=reverse(priRNA.getSeq3());
        String str3=reverse(priRNA.getStr3());
        int size=priRNA.getLength();

        
        /*
          output is on four lines. sequence with '.' are on lines 1 and 4
          sequences with '(' and ')' go on lines 2 & 3 respectively.
        */
        int i = 0, j = 0, n = 0;
        int[] index = new int[size];
        while (i < seq5.length() && j < seq3.length()) {
            if (str5.charAt(i) == '.') {
                pril1.append(seq5.charAt(i));
                pril2.append(' ');
                pril3.append(' ');
                index[i] = n;
                i += 1;
                if (str3.charAt(j) == '.') {
                    pril4.append(seq3.charAt(j));
                    index[size - 1 - j] = n;
                    j += 1;
                } else {
                    pril4.append(' ');
                }
            } else {
                pril1.append(' ');
                if (str3.charAt(j) == '.') {
                    pril2.append(' ');
                    pril3.append(' ');
                    pril4.append(seq3.charAt(j));
                    index[size - 1 - j] = n;
                    j += 1;
                } else {
                    pril2.append(seq5.charAt(i));
                    pril3.append(seq3.charAt(j));
                    pril4.append(' ');
                    index[i] = n;
                    index[size - 1 - j] = n;
                    i += 1;
                    j += 1;
                }
            }
            n++;
        }

        priRNA.setPriLine1(pril1.toString());
        priRNA.setPriLine2(pril2.toString());
        priRNA.setPriLine3(pril3.toString());
        priRNA.setPriLine4(pril4.toString());

        return index;
    }

    
    
    /**
     * reverse string
     * 
     * @param String str
     * @return String reverse str
     */
    public String reverse(String strIn) {
        StringBuilder strReversed = new StringBuilder();
        for (int i = strIn.length() - 1; i >= 0; i--) {
            strReversed.append(strIn.charAt(i));
        }
        return strReversed.toString();
    }

    /**
     * transform structure plot to seq
     * @param String s1: the first line of one side of the plot
     * @param String s2: the second line of one side of the plot
     * @return
     */
    public String PrettyPlot2Seq(String s1, String s2) {
        StringBuilder seq = new StringBuilder();

        for (int i = 0; i < s1.length(); i++) {
            seq.append(s1.charAt(i)).append(s2.charAt(i));
            
        }
        return seq.toString().replace(" ", "");
    }

    /**
     * calculate the GC content
     * @param String seq
     * @return float: the GC content of the seq
     */
//    public float contentGC(String seq) {
//        String s = seq.replaceAll("[CGcg]", "");
//        if (seq.length() == 0) {
//            return 0;
//        }
//        return 1 - (float) s.length() / seq.length();
//
//    }
    public float GCcontent(String seq){
        return NTcontent(seq,'G') + NTcontent(seq,'C') + NTcontent(seq,'g') + NTcontent(seq,'c');
    }

    /**
     * calculate the nt(a,t,g,c,u) content
     * @param String seq
     * @param String nt: a,t,g,c,u
     * @return float: the content of a nt
     */
//    public float contentNT(String seq, String nt) {
//        String s = seq.replaceAll(nt, "");
//        if (seq.length() == 0) {
//            return 0;
//        }
//        return 1 - (float) s.length() / seq.length();
//    }
    public float NTcontent(String seq, char nt){       
        return (float)NTcount(seq,nt)/seq.length();
    }
    
    
    
    
    private int NTcount(String seq, char nt){
        char[] cs=seq.toCharArray();
        int n=0;
        for(char c:cs){
            if(c==nt){
                n++;
            }
        }
        return n;
    }


    
    /**
     * 
     * count the number of GU-pairs.
     * This works based on the assumption there can only be G-C and G-U pairing,
     * which is (it seems) an assumption of RNAFold. 
     * 
     * @param line2
     * @param line3
     * @return int : the number of GU-wobble pairs
     */
    public int CountRNAFoldGUpairs(String line2, String line3){
        int n=line2.length()+line3.length();
        int nc=n-(NTcount(line2,'C')+NTcount(line2,'c')+NTcount(line3,'C')+NTcount(line3,'c'));
        int ng=n-(NTcount(line2,'G')+NTcount(line2,'g')+NTcount(line3,'G')+NTcount(line3,'g'));
        return nc-ng;
    }

    
    
    /**
     * When counting the number of unpaired bases, it does not include the basal 
     * segment or the terminal loop.
     * 
     * e.g.
     * 
     *       A      UU   G   U             UA  G UA AC    
     *        UCCGGG  GAG UAG AGGUUGUAUGGUU  GA U  C      
     *        ||||||  ||| ||| |||||||||||||  || |  |  C
     *        AGGUUC  UUC AUC UCCAACAUGUCAA  UU A  G      
     *              CU   G   U                 G GG UC    
     * BASAL | <------ COUNT IN THIS PART ------>  | TERMINAL LOOP
     * 
     * 
     * @return int 
     */
    public int countNumberOfUnpairedBasesInStem(){
        return unpairedCount(priStructLine1,priStructLine4) 
          - priRNA.getBasalBaseNum() 
          - (priRNA.getTerminalLoopSeq().length() - priRNA.getMidBase().length());
    }
    
    /**
     * calculate the number of paired nucleotides in the defined structure
     * @param  line2 String
     * @return int: the number of pairs
     */
    public int pairCount(String line2){
        return line2.length()-NTcount(line2,' ');
    }

    
    
    /**
     * calculate the number of unpaired bases
     * @param line1 String
     * @param line4 String
     * @return int: the number of unpaired bases
     */
    public int unpairedCount(String line1, String line4){
        return line1.length()-NTcount(line1,' ')+line4.length()-NTcount(line4,' ');
    }

    
    
    
    /**
     * calculate the unpaired rate
     * 
     * @param unpaired int : the number of unpaired bases
     * @param paired int : the number of pairs
     * @return float: the rate of unpaired bases rate
     */
    public float calcUnpairedRate(int unpaired, int paired) {
        int sum = unpaired + paired * 2;
        if (sum == 0) {
            return 0;
        }
        return (float) unpaired / sum;
    }

    /**
     * calculate the internal loop number
     * 
     * @param  line2 String
     * @return int: the number of internal loop number
     * 
     */
    public int internalLoopCount(String line2){
        char[] l=line2.toCharArray();
        int n=0;
        int size=l.length;
        for(int i=0;i<size-1;i++){
            if(l[i]!=' ' && l[i+1]==' '){
                n+=1;
            }
        }
        if(l[size-1]==' '){
            n-=1;
        }
        return n;
    }

    
    
    /**
     * find the largest internal loop (excluding the Terminal Loop) on Stem
     * 
     * @param  line1 String
     * @param  line4 String
     * @return int: the size of the maximal internal loop
     * 
     */
    public int findLargestInternalLoopOnStem(String line1, String line4){
        return Math.max(findLargestInternalLoopOnStemArm(line1), 
                findLargestInternalLoopOnStemArm(line4));
    }
//    public int internalLoopSize(String line1, String line4) {
//        String l1=line1.replaceAll("^\\w+\\s+","").replaceAll("\\s+\\w+$", " ");
//        String l4=line4.replaceAll("^\\w+\\s+"," ").replaceAll("\\s+\\w+$", "");
//        String[] s = (l1 + l4).replaceAll("\\s+", " ").split(" ");
//        int loop = 0;
//        for (int i = 0; i < s.length; i++) {
//            loop = Math.max(loop, s[i].length());
//        }
//        return loop;
//    }
    
    
    
    /**
     * Find the largest internal loop on specified Stem Arm
     * 
     * @param UnpairedTopOrBottomString sequence of unbound nucleotides 
     *                                  (Top or Bottom String from pretty plot)
     * @return 
     */
    private int findLargestInternalLoopOnStemArm(String UnpairedTopOrBottomString){
        
        char[] unpairedArray = UnpairedTopOrBottomString.toCharArray();
        int armLength = unpairedArray.length;
        
        
        int firstBulge=0;
        for(int nt=0;nt<armLength;nt++){
            if(unpairedArray[nt]==' '){
                firstBulge=nt;
                break;
            }
        }
        
        
        int lastBulge=0;
        for(int nt=armLength-1;nt>0;nt--){
            if(unpairedArray[nt]==' '){
                lastBulge=nt;
                break;
            }
        }
        
        
        int maxBulge=0;
        int thisBulge=0;
        for(int nt=firstBulge;nt<lastBulge;nt++){
            if(unpairedArray[nt]==' ' && unpairedArray[nt+1]!=' '){
                thisBulge=1;
            }
            else if(unpairedArray[nt]!=' ' && unpairedArray[nt+1]!=' '){
                thisBulge+=1;
            }
            else if(unpairedArray[nt]!=' ' && unpairedArray[nt+1]==' '){
                if(thisBulge>maxBulge){
                    maxBulge=thisBulge;
                }
            }
        }
        
        return maxBulge;
    }

    
    
    /**
     * determine the strand of the miRNA on primiRNA
     * @param priRNA
     * @param miRNAStart : miRNA start position, count from 0
     * @param miRNAsize  : miRNA length
     * 
     * @return strand : int 5, 3, or 0
     */
    public static int findStrand(PriMiRNA priRNA, int miRNAStart, int miRNAsize){
        if(miRNAStart+miRNAsize<=priRNA.getSeq5().length())
            return 5;
        else if(miRNAStart+1>priRNA.getSeq5().length() + priRNA.getMidBase().length() 
          && miRNAStart+miRNAsize<=priRNA.getLength())
            return 3;
        else return 0;
    }

    
    
    /**
     * generate the 3' 2nt overhang
     * @param end--miRNA end position
     * @param line1
     * @param line2
     * @return
     */
    public String findDangleSeq(int end, String line1, String line2) {
        String dangle="";
        int i=1;
        StringBuilder d=new StringBuilder();
        while(dangle.length()<2 && end+i<line1.length()){
//            dangle=dangle+line1.charAt(end+i)+line2.charAt(end+i);
            d.append(line1.charAt(end+i)).append(line2.charAt(end+i));
            dangle=d.toString().replaceAll("\\s+", "");
            i++;
        }
        if(dangle.length()==1)
            dangle+=" ";
        else if(dangle.length()==0)
            dangle="  ";
        return dangle;
    }

    
    
    /**
     * calculate miRNA stability
     * this is based on rate of the number of hydrogen bonds at two sides of miRNA)
     * 
     * @param  line2 String
     * @param  line3 String
     * @param  strand int: the strand of miRNA
     * @return float: the stability of miRNA
     */
//    public float stability(String line2, String line3, int strand) {
//        int u = (line2.substring(0, 4) + line3.substring(0, 4)).replaceAll("\\s+", "").replaceAll("[cC]", "xx").length();
//        int d = (line2.substring(line2.length() - 4) + line3.substring(line3.length() - 4)).replaceAll("\\s+", "").replaceAll("[cC]", "xx").length();
//        if (d == 0 || u == 0) {
//            return 0;
//        }
//        if (strand == 5) {
//            return (float) u / d;
//        } else if (strand == 3) {
//            return (float) d / u;
//        } else {
//            return 0;
//        }
//    }
    public float stability(String line2, String line3, int strand){
        
        int u=0;
        char[] l2=line2.toCharArray();
        char[] l3=line3.toCharArray();
        for(int i=0;i<4;i++){
            if(l2[i]==' ') continue;
            else if(l2[i]=='c') u+=2;
            else if(l2[i]=='C') u+=2;
            else u+=1;
        }
        for(int i=0;i<4;i++){
            if(l3[i]==' ') continue;
            else if(l3[i]=='c') u+=2;
            else if(l3[i]=='C') u+=2;
            else u+=1;
        }
        int d=0;
        int n2=l2.length;
        int n3=l3.length;
        for(int i=1;i<5;i++){
            if(l2[n2-i]==' ') continue;
            else if(l2[n2-i]=='c') d+=2;
            else if(l2[n2-i]=='C') d+=2;
            else d+=1;
        }
        for(int i=1;i<5;i++){
            if(l3[n3-i]==' ') continue;
            else if(l3[n3-i]=='c') d+=2;
            else if(l3[n3-i]=='C') d+=2;
            else d+=1;
        }
        if (d == 0 || u == 0) {
            return 0;
        }
        if (strand == 5) {
            return (float) u / d;
        } else if (strand == 3) {
            return (float) d / u;
        } else {
            return 0;
        }
    }

    
    
    /**
     * calculate energy of pre-miRNA defined by the start position
     * and pre-miRNA sequence.
     * Because we are trying to predict miRNAs, there may be many pre-miRNAs
     * associated with different miRNA candidates.
     *  
     * @param priStructStr : String - structure of parent pri-miRNA
     * @param preSeq       : String - sequence of this pre-miRNA candidate
     * @param start        : int    - start position of pre-miRNA candidate
     *                                within the parent pri-miRNA
     * @return             : float  - MFE of the pre-miRNA candidate
     * 
     */
    public float calculatePreMFE(String priStructStr, String preSeq, int start) {
        
        int end = start + preSeq.length();
        String preStr = priStructStr.substring(start, end);
        
        return MfeFoldRNA.foldSequence(preSeq, preStr);
    }

    
    
    /**
     * pri-miRNA hairpin structure
     * @param priRNA
     * @return
     */
    public static String setStrPlot(PriMiRNA priRNA){
//        String line1="",line2="",line3="",line4="",line5="";
        String priLine1=priRNA.getPriLine1();
        String priLine2=priRNA.getPriLine2();
        String priLine3=priRNA.getPriLine3();
        String priLine4=priRNA.getPriLine4();
        StringBuilder sp=new StringBuilder();
//        line1=priLine1.substring(0, priLine1.length()-1);
        sp.append(priLine1.substring(0, priLine1.length()-1)).append("\n");
//        line2=priLine2.substring(0,priLine3.length()-1)+priLine1.substring(priLine1.length()-1);
        sp.append(priLine2.substring(0,priLine3.length()-1)).append(priLine1.substring(priLine1.length()-1)).append("\n");
//        line3=priLine2.substring(0, priLine2.length()-1).replaceAll("\\S", "|")+priRNA.getMidBase();
        sp.append(priLine2.substring(0, priLine2.length()-1).replaceAll("\\S", "|")).append(priRNA.getMidBase()).append("\n");
//        line4=priLine3.substring(0,priLine3.length()-1)+priLine4.substring(priLine4.length()-1);
        sp.append(priLine3.substring(0,priLine3.length()-1)).append(priLine4.substring(priLine4.length()-1)).append("\n");
//        line5=priLine4.substring(0, priLine4.length()-1);
        sp.append(priLine4.substring(0, priLine4.length()-1));
        
//        return line1+"\n"+line2+"\n"+line3+"\n"+line4+"\n"+line5;
        return sp.toString();
    }

    
    

    /**
     * pri-miRNA hairpin structure, miRNA region is highlighted by uppercase letter
     * 
     * @param priRNA
     * @param upperStart
     * @param upperEnd
     * @param strand
     * @return
     */
    public String generatePrettyPlotShowingMiRNA(PriMiRNA priRNA, int upperStart, int upperEnd, int strand){
        StringBuilder structureString=new StringBuilder();
        if(strand==5){
            if(upperEnd+1<priStructLine1.length()-1){
                structureString.append(priStructLine1.substring(0, upperStart).toLowerCase())
                        .append(priStructLine1.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine1.substring(upperEnd+1, priStructLine1.length()-1).toLowerCase()).append("\n");
                
                structureString.append(priStructLine2.substring(0, upperStart).toLowerCase())
                        .append(priStructLine2.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine2.substring(upperEnd+1, priStructLine2.length()-1).toLowerCase())
                        .append(priStructLine1.substring(priStructLine1.length()-1).toLowerCase()).append("\n");
            }
            structureString.append(priStructLine2.substring(0, priStructLine2.length()-1).replaceAll("\\S", "|"))
                    .append(priRNA.getMidBase().toLowerCase()).append("\n");
            structureString.append(priStructLine3.substring(0,priStructLine3.length()-1).toLowerCase())
                    .append(priStructLine4.substring(priStructLine4.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine4.substring(0, priStructLine4.length()-1).toLowerCase());

        }
        else{
            structureString.append(priStructLine1.substring(0, priStructLine1.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine2.substring(0,priStructLine2.length()-1).toLowerCase())
                    .append(priStructLine1.substring(priStructLine1.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine2.substring(0, priStructLine2.length()-1).replaceAll("\\S", "|"))
                    .append(priRNA.getMidBase().toLowerCase()).append("\n");
            if(upperEnd+1<priStructLine1.length()-1){
                structureString.append(priStructLine3.substring(0, upperStart).toLowerCase())
                        .append(priStructLine3.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine3.substring(upperEnd+1, priStructLine3.length()-1).toLowerCase())
                        .append(priStructLine4.substring(priStructLine4.length()-1).toLowerCase()).append("\n");
                structureString.append(priStructLine4.substring(0, upperStart).toLowerCase())
                        .append(priStructLine4.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine4.substring(upperEnd+1, priStructLine4.length()-1).toLowerCase());
            }

        }
        return structureString.toString();
    }

   

    /**
     * gather all the features of a pri-miRNA and its pre-miRNA and miRNA 
     * to store in a HashMap
     * before calling, the miRNA, pre-miRNA and pri-miRNA need to be defined,
     * so this cannot be called on, for example, the pre-miRNA only
     * 
     * @return HashMap of features
     * 
     */
    public HashMap characterizePriPreMiTriplet(){

        HashMap tripletFeatures=new HashMap();

        tripletFeatures.putAll(priRNA.getFeatureSet());
        tripletFeatures.put("plot", priRNA.getPriPlot());
        tripletFeatures.putAll(preRNA.getFeatureSet());
        tripletFeatures.putAll(miRNA.getFeatureSet());


        return tripletFeatures;
    }


}
